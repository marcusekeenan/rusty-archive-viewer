// This file is @generated by prost-build.
/// Base field value structure for metadata
#[derive(serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FieldValue {
    #[prost(string, required, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, required, tag = "2")]
    pub val: ::prost::alloc::string::String,
}
/// Scalar types
#[derive(serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScalarString {
    #[prost(uint32, required, tag = "1")]
    pub secondsintoyear: u32,
    #[prost(uint32, required, tag = "2")]
    pub nano: u32,
    #[prost(string, required, tag = "3")]
    pub val: ::prost::alloc::string::String,
    #[prost(int32, optional, tag = "4")]
    pub severity: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub status: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "6")]
    pub repeatcount: ::core::option::Option<u32>,
    #[prost(message, repeated, tag = "7")]
    pub fieldvalues: ::prost::alloc::vec::Vec<FieldValue>,
    #[prost(bool, optional, tag = "8")]
    pub fieldactualchange: ::core::option::Option<bool>,
}
#[derive(serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScalarByte {
    #[prost(uint32, required, tag = "1")]
    pub secondsintoyear: u32,
    #[prost(uint32, required, tag = "2")]
    pub nano: u32,
    #[prost(bytes = "vec", required, tag = "3")]
    pub val: ::prost::alloc::vec::Vec<u8>,
    #[prost(int32, optional, tag = "4")]
    pub severity: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub status: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "6")]
    pub repeatcount: ::core::option::Option<u32>,
    #[prost(message, repeated, tag = "7")]
    pub fieldvalues: ::prost::alloc::vec::Vec<FieldValue>,
    #[prost(bool, optional, tag = "8")]
    pub fieldactualchange: ::core::option::Option<bool>,
}
#[derive(serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScalarShort {
    #[prost(uint32, required, tag = "1")]
    pub secondsintoyear: u32,
    #[prost(uint32, required, tag = "2")]
    pub nano: u32,
    #[prost(sint32, required, tag = "3")]
    pub val: i32,
    #[prost(int32, optional, tag = "4")]
    pub severity: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub status: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "6")]
    pub repeatcount: ::core::option::Option<u32>,
    #[prost(message, repeated, tag = "7")]
    pub fieldvalues: ::prost::alloc::vec::Vec<FieldValue>,
    #[prost(bool, optional, tag = "8")]
    pub fieldactualchange: ::core::option::Option<bool>,
}
#[derive(serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScalarInt {
    #[prost(uint32, required, tag = "1")]
    pub secondsintoyear: u32,
    #[prost(uint32, required, tag = "2")]
    pub nano: u32,
    #[prost(sfixed32, required, tag = "3")]
    pub val: i32,
    #[prost(int32, optional, tag = "4")]
    pub severity: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub status: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "6")]
    pub repeatcount: ::core::option::Option<u32>,
    #[prost(message, repeated, tag = "7")]
    pub fieldvalues: ::prost::alloc::vec::Vec<FieldValue>,
    #[prost(bool, optional, tag = "8")]
    pub fieldactualchange: ::core::option::Option<bool>,
}
#[derive(serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScalarEnum {
    #[prost(uint32, required, tag = "1")]
    pub secondsintoyear: u32,
    #[prost(uint32, required, tag = "2")]
    pub nano: u32,
    #[prost(sint32, required, tag = "3")]
    pub val: i32,
    #[prost(int32, optional, tag = "4")]
    pub severity: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub status: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "6")]
    pub repeatcount: ::core::option::Option<u32>,
    #[prost(message, repeated, tag = "7")]
    pub fieldvalues: ::prost::alloc::vec::Vec<FieldValue>,
    #[prost(bool, optional, tag = "8")]
    pub fieldactualchange: ::core::option::Option<bool>,
}
#[derive(serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScalarFloat {
    #[prost(uint32, required, tag = "1")]
    pub secondsintoyear: u32,
    #[prost(uint32, required, tag = "2")]
    pub nano: u32,
    #[prost(float, required, tag = "3")]
    pub val: f32,
    #[prost(int32, optional, tag = "4")]
    pub severity: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub status: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "6")]
    pub repeatcount: ::core::option::Option<u32>,
    #[prost(message, repeated, tag = "7")]
    pub fieldvalues: ::prost::alloc::vec::Vec<FieldValue>,
    #[prost(bool, optional, tag = "8")]
    pub fieldactualchange: ::core::option::Option<bool>,
}
#[derive(serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScalarDouble {
    #[prost(uint32, required, tag = "1")]
    pub secondsintoyear: u32,
    #[prost(uint32, required, tag = "2")]
    pub nano: u32,
    #[prost(double, required, tag = "3")]
    pub val: f64,
    #[prost(int32, optional, tag = "4")]
    pub severity: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub status: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "6")]
    pub repeatcount: ::core::option::Option<u32>,
    #[prost(message, repeated, tag = "7")]
    pub fieldvalues: ::prost::alloc::vec::Vec<FieldValue>,
    #[prost(bool, optional, tag = "8")]
    pub fieldactualchange: ::core::option::Option<bool>,
}
/// Vector types
#[derive(serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VectorString {
    #[prost(uint32, required, tag = "1")]
    pub secondsintoyear: u32,
    #[prost(uint32, required, tag = "2")]
    pub nano: u32,
    #[prost(string, repeated, tag = "3")]
    pub val: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "4")]
    pub severity: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub status: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "6")]
    pub repeatcount: ::core::option::Option<u32>,
    #[prost(message, repeated, tag = "7")]
    pub fieldvalues: ::prost::alloc::vec::Vec<FieldValue>,
    #[prost(bool, optional, tag = "8")]
    pub fieldactualchange: ::core::option::Option<bool>,
}
#[derive(serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VectorChar {
    #[prost(uint32, required, tag = "1")]
    pub secondsintoyear: u32,
    #[prost(uint32, required, tag = "2")]
    pub nano: u32,
    #[prost(bytes = "vec", required, tag = "3")]
    pub val: ::prost::alloc::vec::Vec<u8>,
    #[prost(int32, optional, tag = "4")]
    pub severity: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub status: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "6")]
    pub repeatcount: ::core::option::Option<u32>,
    #[prost(message, repeated, tag = "7")]
    pub fieldvalues: ::prost::alloc::vec::Vec<FieldValue>,
    #[prost(bool, optional, tag = "8")]
    pub fieldactualchange: ::core::option::Option<bool>,
}
#[derive(serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VectorShort {
    #[prost(uint32, required, tag = "1")]
    pub secondsintoyear: u32,
    #[prost(uint32, required, tag = "2")]
    pub nano: u32,
    #[prost(sint32, repeated, tag = "3")]
    pub val: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, optional, tag = "4")]
    pub severity: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub status: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "6")]
    pub repeatcount: ::core::option::Option<u32>,
    #[prost(message, repeated, tag = "7")]
    pub fieldvalues: ::prost::alloc::vec::Vec<FieldValue>,
    #[prost(bool, optional, tag = "8")]
    pub fieldactualchange: ::core::option::Option<bool>,
}
#[derive(serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VectorInt {
    #[prost(uint32, required, tag = "1")]
    pub secondsintoyear: u32,
    #[prost(uint32, required, tag = "2")]
    pub nano: u32,
    #[prost(sfixed32, repeated, tag = "3")]
    pub val: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, optional, tag = "4")]
    pub severity: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub status: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "6")]
    pub repeatcount: ::core::option::Option<u32>,
    #[prost(message, repeated, tag = "7")]
    pub fieldvalues: ::prost::alloc::vec::Vec<FieldValue>,
    #[prost(bool, optional, tag = "8")]
    pub fieldactualchange: ::core::option::Option<bool>,
}
#[derive(serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VectorEnum {
    #[prost(uint32, required, tag = "1")]
    pub secondsintoyear: u32,
    #[prost(uint32, required, tag = "2")]
    pub nano: u32,
    #[prost(sint32, repeated, tag = "3")]
    pub val: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, optional, tag = "4")]
    pub severity: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub status: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "6")]
    pub repeatcount: ::core::option::Option<u32>,
    #[prost(message, repeated, tag = "7")]
    pub fieldvalues: ::prost::alloc::vec::Vec<FieldValue>,
    #[prost(bool, optional, tag = "8")]
    pub fieldactualchange: ::core::option::Option<bool>,
}
#[derive(serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VectorFloat {
    #[prost(uint32, required, tag = "1")]
    pub secondsintoyear: u32,
    #[prost(uint32, required, tag = "2")]
    pub nano: u32,
    #[prost(float, repeated, tag = "3")]
    pub val: ::prost::alloc::vec::Vec<f32>,
    #[prost(int32, optional, tag = "4")]
    pub severity: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub status: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "6")]
    pub repeatcount: ::core::option::Option<u32>,
    #[prost(message, repeated, tag = "7")]
    pub fieldvalues: ::prost::alloc::vec::Vec<FieldValue>,
    #[prost(bool, optional, tag = "8")]
    pub fieldactualchange: ::core::option::Option<bool>,
}
#[derive(serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VectorDouble {
    #[prost(uint32, required, tag = "1")]
    pub secondsintoyear: u32,
    #[prost(uint32, required, tag = "2")]
    pub nano: u32,
    #[prost(double, repeated, tag = "3")]
    pub val: ::prost::alloc::vec::Vec<f64>,
    #[prost(int32, optional, tag = "4")]
    pub severity: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub status: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "6")]
    pub repeatcount: ::core::option::Option<u32>,
    #[prost(message, repeated, tag = "7")]
    pub fieldvalues: ::prost::alloc::vec::Vec<FieldValue>,
    #[prost(bool, optional, tag = "8")]
    pub fieldactualchange: ::core::option::Option<bool>,
}
/// V4 Generic type
#[derive(serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct V4GenericBytes {
    #[prost(uint32, required, tag = "1")]
    pub secondsintoyear: u32,
    #[prost(uint32, required, tag = "2")]
    pub nano: u32,
    #[prost(bytes = "vec", required, tag = "3")]
    pub val: ::prost::alloc::vec::Vec<u8>,
    #[prost(int32, optional, tag = "4")]
    pub severity: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub status: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "6")]
    pub repeatcount: ::core::option::Option<u32>,
    #[prost(message, repeated, tag = "7")]
    pub fieldvalues: ::prost::alloc::vec::Vec<FieldValue>,
    #[prost(bool, optional, tag = "8")]
    pub fieldactualchange: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "9")]
    pub user_tag: ::core::option::Option<u32>,
}
/// Payload info message
#[derive(serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PayloadInfo {
    #[prost(enumeration = "PayloadType", required, tag = "1")]
    pub r#type: i32,
    #[prost(string, required, tag = "2")]
    pub pvname: ::prost::alloc::string::String,
    #[prost(int32, required, tag = "3")]
    pub year: i32,
    #[prost(int32, optional, tag = "4")]
    pub element_count: ::core::option::Option<i32>,
    /// Items from 5 to 14 are no longer to be used.
    /// Stick these into the headers using the field names
    /// For example, units comes in as EGU in the headers.
    #[prost(double, optional, tag = "5")]
    pub unused00: ::core::option::Option<f64>,
    #[prost(double, optional, tag = "6")]
    pub unused01: ::core::option::Option<f64>,
    #[prost(double, optional, tag = "7")]
    pub unused02: ::core::option::Option<f64>,
    #[prost(double, optional, tag = "8")]
    pub unused03: ::core::option::Option<f64>,
    #[prost(double, optional, tag = "9")]
    pub unused04: ::core::option::Option<f64>,
    #[prost(double, optional, tag = "10")]
    pub unused05: ::core::option::Option<f64>,
    #[prost(double, optional, tag = "11")]
    pub unused06: ::core::option::Option<f64>,
    #[prost(double, optional, tag = "12")]
    pub unused07: ::core::option::Option<f64>,
    #[prost(double, optional, tag = "13")]
    pub unused08: ::core::option::Option<f64>,
    #[prost(string, optional, tag = "14")]
    pub unused09: ::core::option::Option<::prost::alloc::string::String>,
    /// End of unused elements
    #[prost(message, repeated, tag = "15")]
    pub headers: ::prost::alloc::vec::Vec<FieldValue>,
}
/// Payload type enumeration
#[derive(serde::Serialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PayloadType {
    ScalarString = 0,
    ScalarShort = 1,
    ScalarFloat = 2,
    ScalarEnum = 3,
    ScalarByte = 4,
    ScalarInt = 5,
    ScalarDouble = 6,
    WaveformString = 7,
    WaveformShort = 8,
    WaveformFloat = 9,
    WaveformEnum = 10,
    WaveformByte = 11,
    WaveformInt = 12,
    WaveformDouble = 13,
    V4GenericBytes = 14,
}
impl PayloadType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            PayloadType::ScalarString => "SCALAR_STRING",
            PayloadType::ScalarShort => "SCALAR_SHORT",
            PayloadType::ScalarFloat => "SCALAR_FLOAT",
            PayloadType::ScalarEnum => "SCALAR_ENUM",
            PayloadType::ScalarByte => "SCALAR_BYTE",
            PayloadType::ScalarInt => "SCALAR_INT",
            PayloadType::ScalarDouble => "SCALAR_DOUBLE",
            PayloadType::WaveformString => "WAVEFORM_STRING",
            PayloadType::WaveformShort => "WAVEFORM_SHORT",
            PayloadType::WaveformFloat => "WAVEFORM_FLOAT",
            PayloadType::WaveformEnum => "WAVEFORM_ENUM",
            PayloadType::WaveformByte => "WAVEFORM_BYTE",
            PayloadType::WaveformInt => "WAVEFORM_INT",
            PayloadType::WaveformDouble => "WAVEFORM_DOUBLE",
            PayloadType::V4GenericBytes => "V4_GENERIC_BYTES",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SCALAR_STRING" => Some(Self::ScalarString),
            "SCALAR_SHORT" => Some(Self::ScalarShort),
            "SCALAR_FLOAT" => Some(Self::ScalarFloat),
            "SCALAR_ENUM" => Some(Self::ScalarEnum),
            "SCALAR_BYTE" => Some(Self::ScalarByte),
            "SCALAR_INT" => Some(Self::ScalarInt),
            "SCALAR_DOUBLE" => Some(Self::ScalarDouble),
            "WAVEFORM_STRING" => Some(Self::WaveformString),
            "WAVEFORM_SHORT" => Some(Self::WaveformShort),
            "WAVEFORM_FLOAT" => Some(Self::WaveformFloat),
            "WAVEFORM_ENUM" => Some(Self::WaveformEnum),
            "WAVEFORM_BYTE" => Some(Self::WaveformByte),
            "WAVEFORM_INT" => Some(Self::WaveformInt),
            "WAVEFORM_DOUBLE" => Some(Self::WaveformDouble),
            "V4_GENERIC_BYTES" => Some(Self::V4GenericBytes),
            _ => None,
        }
    }
}
